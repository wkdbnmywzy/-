<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>交点检测和分割测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            background: #f9f9f9;
            border-left: 4px solid #4CAF50;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        .success {
            color: #4CAF50;
            font-weight: bold;
        }
        .error {
            color: #f44336;
            font-weight: bold;
        }
        .info {
            color: #2196F3;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        #log {
            background: #333;
            color: #0f0;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .test-canvas {
            border: 1px solid #ddd;
            margin: 10px 0;
            background: white;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>KML交点检测和分割测试</h1>

        <div class="test-section">
            <h2>测试控制</h2>
            <button onclick="runAllTests()">运行所有测试</button>
            <button onclick="testEndpointOnLine()">测试端点在线上</button>
            <button onclick="testNormalIntersection()">测试普通交点</button>
            <button onclick="testComplexNetwork()">测试复杂网络</button>
            <button onclick="clearLog()">清空日志</button>
        </div>

        <div class="test-section">
            <h2>可视化</h2>
            <canvas id="testCanvas" class="test-canvas" width="800" height="400"></canvas>
        </div>

        <div class="test-section">
            <h2>测试结果</h2>
            <div id="testResults"></div>
        </div>

        <div class="test-section">
            <h2>详细日志</h2>
            <div id="log"></div>
        </div>
    </div>

    <script>
        // 日志函数
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            let prefix = '[INFO]';
            let color = '#0f0';

            if (type === 'error') {
                prefix = '[ERROR]';
                color = '#f00';
            } else if (type === 'success') {
                prefix = '[SUCCESS]';
                color = '#0ff';
            } else if (type === 'warning') {
                prefix = '[WARNING]';
                color = '#ff0';
            }

            logDiv.innerHTML += `<span style="color: ${color}">${timestamp} ${prefix} ${message}</span>\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            document.getElementById('testResults').innerHTML = '';
            log('日志已清空', 'info');
        }

        // 绘制函数
        function drawLines(lines, intersections = []) {
            const canvas = document.getElementById('testCanvas');
            const ctx = canvas.getContext('2d');

            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 设置坐标变换（将测试坐标映射到画布）
            const scale = 50;
            const offsetX = 100;
            const offsetY = 200;

            // 绘制网格
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // 绘制线段
            lines.forEach((line, index) => {
                ctx.strokeStyle = `hsl(${index * 60}, 70%, 50%)`;
                ctx.lineWidth = 2;
                ctx.beginPath();

                const coords = line.coordinates || line;
                for (let i = 0; i < coords.length; i++) {
                    const x = coords[i][0] * scale + offsetX;
                    const y = canvas.height - (coords[i][1] * scale + offsetY);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // 绘制端点
                ctx.fillStyle = ctx.strokeStyle;
                for (let i = 0; i < coords.length; i++) {
                    const x = coords[i][0] * scale + offsetX;
                    const y = canvas.height - (coords[i][1] * scale + offsetY);

                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            // 绘制交点
            ctx.fillStyle = '#ff0000';
            intersections.forEach(inter => {
                const x = inter.point[0] * scale + offsetX;
                const y = canvas.height - (inter.point[1] * scale + offsetY);

                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();

                // 标注交点类型
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.fillText(inter.type === 'endpoint_on_line' ? 'E' : 'N', x + 8, y - 8);
                ctx.fillStyle = '#ff0000';
            });
        }

        // 模拟交点检测函数
        function checkEndpointOnLine(p1Start, p1End, p2Start, p2End) {
            const epsilon = 1e-9;

            // 简化的端点在线检测
            function isPointOnSegment(point, segStart, segEnd) {
                const dx = segEnd[0] - segStart[0];
                const dy = segEnd[1] - segStart[1];

                if (Math.abs(dx) < epsilon && Math.abs(dy) < epsilon) {
                    return null;
                }

                let t;
                if (Math.abs(dx) > Math.abs(dy)) {
                    t = (point[0] - segStart[0]) / dx;
                } else {
                    t = (point[1] - segStart[1]) / dy;
                }

                if (t <= epsilon || t >= 1 - epsilon) {
                    return null;
                }

                const projX = segStart[0] + t * dx;
                const projY = segStart[1] + t * dy;
                const dist = Math.sqrt(Math.pow(point[0] - projX, 2) + Math.pow(point[1] - projY, 2));

                if (dist < 0.01) {
                    return t;
                }

                return null;
            }

            // 检查各个端点
            if (isPointOnSegment(p1Start, p2Start, p2End) !== null) {
                return { point: p1Start, whichEndpoint: 'line1_start', type: 'endpoint_on_line' };
            }
            if (isPointOnSegment(p1End, p2Start, p2End) !== null) {
                return { point: p1End, whichEndpoint: 'line1_end', type: 'endpoint_on_line' };
            }
            if (isPointOnSegment(p2Start, p1Start, p1End) !== null) {
                return { point: p2Start, whichEndpoint: 'line2_start', type: 'endpoint_on_line' };
            }
            if (isPointOnSegment(p2End, p1Start, p1End) !== null) {
                return { point: p2End, whichEndpoint: 'line2_end', type: 'endpoint_on_line' };
            }

            return null;
        }

        function getSegmentIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

            if (Math.abs(denom) < 1e-10) {
                return null;
            }

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

            const epsilon = 0.0001;
            const t_interior = t > epsilon && t < (1 - epsilon);
            const u_interior = u > epsilon && u < (1 - epsilon);

            if (t >= -epsilon && t <= (1 + epsilon) &&
                u >= -epsilon && u <= (1 + epsilon) &&
                t_interior && u_interior) {
                return {
                    point: [x1 + t * (x2 - x1), y1 + t * (y2 - y1)],
                    type: 'normal_intersection'
                };
            }

            return null;
        }

        // 测试函数
        function testEndpointOnLine() {
            log('开始测试端点在线上的情况...', 'info');

            // T字形相交：线段1的端点在线段2上
            const line1 = [[0, 0], [2, 2]];
            const line2 = [[0, 2], [4, 2]];

            const result = checkEndpointOnLine(line1[0], line1[1], line2[0], line2[1]);

            drawLines([line1, line2], result ? [result] : []);

            if (result) {
                log(`检测到端点在线上: ${result.whichEndpoint} at [${result.point[0]}, ${result.point[1]}]`, 'success');
                addTestResult('端点在线测试', '通过', true);
            } else {
                log('未检测到端点在线上', 'error');
                addTestResult('端点在线测试', '失败', false);
            }
        }

        function testNormalIntersection() {
            log('开始测试普通交点...', 'info');

            // X形相交：两条线段在中间相交
            const line1 = [[0, 0], [4, 4]];
            const line2 = [[0, 4], [4, 0]];

            const result = getSegmentIntersection(
                line1[0][0], line1[0][1], line1[1][0], line1[1][1],
                line2[0][0], line2[0][1], line2[1][0], line2[1][1]
            );

            drawLines([line1, line2], result ? [result] : []);

            if (result) {
                log(`检测到普通交点: [${result.point[0].toFixed(2)}, ${result.point[1].toFixed(2)}]`, 'success');
                addTestResult('普通交点测试', '通过', true);
            } else {
                log('未检测到交点', 'error');
                addTestResult('普通交点测试', '失败', false);
            }
        }

        function testComplexNetwork() {
            log('开始测试复杂网络...', 'info');

            // 创建一个更复杂的网络
            const lines = [
                [[0, 0], [5, 0]],      // 水平线
                [[0, 2], [5, 2]],      // 水平线
                [[1, -1], [1, 3]],     // 垂直线
                [[3, -1], [3, 3]],     // 垂直线
                [[0, 1], [5, 1.5]]     // 斜线
            ];

            const intersections = [];

            // 检测所有交点
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 1; j < lines.length; j++) {
                    // 检查端点在线上
                    const endpointCheck = checkEndpointOnLine(
                        lines[i][0], lines[i][1],
                        lines[j][0], lines[j][1]
                    );

                    if (endpointCheck) {
                        intersections.push(endpointCheck);
                    } else {
                        // 检查普通交点
                        const normalCheck = getSegmentIntersection(
                            lines[i][0][0], lines[i][0][1], lines[i][1][0], lines[i][1][1],
                            lines[j][0][0], lines[j][0][1], lines[j][1][0], lines[j][1][1]
                        );

                        if (normalCheck) {
                            intersections.push(normalCheck);
                        }
                    }
                }
            }

            drawLines(lines, intersections);

            const endpointCount = intersections.filter(i => i.type === 'endpoint_on_line').length;
            const normalCount = intersections.filter(i => i.type === 'normal_intersection').length;

            log(`检测到 ${intersections.length} 个交点:`, 'success');
            log(`- 端点在线上: ${endpointCount} 个`, 'info');
            log(`- 普通交点: ${normalCount} 个`, 'info');

            addTestResult('复杂网络测试', `${intersections.length} 个交点`, true);
        }

        function addTestResult(testName, result, success) {
            const resultsDiv = document.getElementById('testResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = 'test-result';
            resultDiv.innerHTML = `
                <span class="${success ? 'success' : 'error'}">${testName}:</span>
                <span>${result}</span>
            `;
            resultsDiv.appendChild(resultDiv);
        }

        function runAllTests() {
            clearLog();
            log('开始运行所有测试...', 'info');

            setTimeout(() => testEndpointOnLine(), 100);
            setTimeout(() => testNormalIntersection(), 1000);
            setTimeout(() => testComplexNetwork(), 2000);

            setTimeout(() => {
                log('所有测试完成！', 'success');
            }, 3000);
        }

        // 页面加载时运行测试
        window.onload = function() {
            log('测试页面已加载，点击按钮开始测试', 'info');
            // 自动运行一个简单测试作为演示
            testComplexNetwork();
        };
    </script>
</body>
</html>